import express from "express";
import mongoose from "mongoose";
import cors from "cors";
import dotenv from "dotenv";
import http from "http";
import { Server } from "socket.io";

import userRoutes from "./routes/user.routes.js";
import gameRoutes from "./routes/game.routes.js";
import questionRoutes from "./routes/question.routes.js";
import gameResultRoutes from "./routes/gameResult.routes.js";
import dashboardRoutes from "./routes/dashboard.routes.js";

import {
  joinLobby,
  setPlayerReady,
  lobbies,
  eliminatePlayerFromLobby,
  declareWinnerInLobby,
  checkGameEndInLobby,
  getAlivePlayers,
  createFinalRankingFromLobby,
  findLobbyBySocketId,
  cleanupLobby,
  removePlayerFromLobby,
  cleanupEmptyLobbies,
  performFullCleanup,
  getLobbiesStats
} from "./lobbies.js";

// ‚úÖ IMPORTAR EL SISTEMA DE SESIONES
import { SessionManager } from "./sessionManager.js";

dotenv.config();

const app = express();
app.use(cors({
  origin: "*",
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"]
}));
app.use(express.json());

// Rutas REST
app.use("/api/users", userRoutes);
app.use("/api/game", gameRoutes);
app.use("/api/questions", questionRoutes);
app.use("/api/results", gameResultRoutes);
app.use("/api/dashboard", dashboardRoutes);

// Conexi√≥n a MongoDB
mongoose.connect(process.env.MONGO_URI || "")
  .then(() => console.log("MongoDB conectado üöÄ"))
  .catch(err => console.error(err));

// Servidor HTTP
const server = http.createServer(app);

// Socket.IO
const io = new Server(server, {
  path: "/socket.io",
  cors: { origin: "*" }
});

// Protecci√≥n contra ejecuci√≥n m√∫ltiple de finishGame
const finishedLobbies = new Set<string>();

// ... [Mantener todas las funciones debug y finishGame igual] ...
function debugLobbyState(lobby: any, context: string) {
  console.log(`\nüîç DEBUG LOBBY STATE - ${context}`);
  console.log(`üìç Lobby ID: ${lobby.id}`);
  console.log(`üìç Game State: ${lobby.gameState}`);
  console.log(`üìç Total Players at Start: ${lobby.totalPlayersAtStart}`);
  console.log(`üìç Players (${lobby.players.length}):`);

  lobby.players.forEach((p: any, index: number) => {
    console.log(`  ${index + 1}. ${p.name}:`);
    console.log(`     - isAlive: ${p.isAlive}`);
    console.log(`     - finalPosition: ${p.finalPosition}`);
    console.log(`     - won: ${p.won}`);
    console.log(`     - correctAnswers: ${p.correctAnswers}`);
    console.log(`     - questionsAnswered: ${p.questionsAnswered}`);
    console.log(`     - eliminationTime: ${p.eliminationTime ? new Date(p.eliminationTime).toISOString() : 'N/A'}`);
    console.log(`     - socketId: ${p.socketId}`);
  });

  console.log(`üìç Elimination Order: ${JSON.stringify(lobby.eliminationOrder || [])}`);
  console.log(`üîç END DEBUG\n`);
}

function createCorrectFinalRanking(lobby: any) {
  console.log(`\nüéØ INICIANDO createCorrectFinalRanking para lobby ${lobby.id}`);

  debugLobbyState(lobby, "ANTES del ranking");

  const totalPlayers = lobby.totalPlayersAtStart || lobby.players.length;
  const positions: Record<string, number> = {};
  const stats: Record<string, any> = {};

  // üö® CR√çTICO: PRIORIZAR ESTAD√çSTICAS DE RENDIMIENTO SOBRE TODO LO DEM√ÅS
  const allPlayersSorted = [...lobby.players].sort((a: any, b: any) => {
    const aCorrect = a.correctAnswers || 0;
    const bCorrect = b.correctAnswers || 0;
    const aAnswered = a.questionsAnswered || 0;
    const bAnswered = b.questionsAnswered || 0;

    console.log(`\nüèÜ COMPARANDO JUGADORES:`);
    console.log(`   ${a.name}: ${aCorrect}/${aAnswered} correctas`);
    console.log(`   ${b.name}: ${bCorrect}/${bAnswered} correctas`);

    // ‚úÖ CRITERIO 1: M√ÅS RESPUESTAS CORRECTAS = SIEMPRE MEJOR POSICI√ìN
    if (aCorrect !== bCorrect) {
      const winner = aCorrect > bCorrect ? a.name : b.name;
      console.log(`   ü•á GANADOR POR CORRECTAS: ${winner} (${aCorrect > bCorrect ? aCorrect : bCorrect} vs ${aCorrect > bCorrect ? bCorrect : aCorrect})`);
      return bCorrect - aCorrect; // Mayor n√∫mero de correctas = mejor posici√≥n
    }

    // ‚úÖ CRITERIO 2: Si empatan en correctas, m√°s preguntas respondidas = mejor
    if (aAnswered !== bAnswered) {
      const winner = aAnswered > bAnswered ? a.name : b.name;
      console.log(`   üìä GANADOR POR RESPONDIDAS: ${winner} (${aAnswered > bAnswered ? aAnswered : bAnswered} vs ${aAnswered > bAnswered ? bAnswered : aAnswered})`);
      return bAnswered - aAnswered;
    }

    // ‚úÖ CRITERIO 3: Si empatan en TODO el rendimiento, jugadores vivos tienen ventaja
    if (a.isAlive && !b.isAlive) {
      console.log(`   üü¢ ${a.name} VIVO vs üî¥ ${b.name} ELIMINADO - Ventaja a vivo`);
      return -1; // a es mejor (vivo)
    }
    if (!a.isAlive && b.isAlive) {
      console.log(`   üî¥ ${a.name} ELIMINADO vs üü¢ ${b.name} VIVO - Ventaja a vivo`);
      return 1;  // b es mejor (vivo)
    }

    // ‚úÖ CRITERIO 4: SOLO si TODO lo anterior empata, usar tiempo de eliminaci√≥n
    if (!a.isAlive && !b.isAlive) {
      const aElimTime = a.eliminationTime || 0;
      const bElimTime = b.eliminationTime || 0;

      // üö® IMPORTANTE: Eliminado M√ÅS TARDE = mejor posici√≥n (sobrevivi√≥ m√°s tiempo)
      if (aElimTime !== bElimTime) {
        const winner = aElimTime > bElimTime ? a.name : b.name;
        console.log(`   ‚è∞ GANADOR POR SUPERVIVENCIA: ${winner}`);
        console.log(`      ${a.name}: ${new Date(aElimTime).toISOString()}`);
        console.log(`      ${b.name}: ${new Date(bElimTime).toISOString()}`);
        return bElimTime - aElimTime; // Eliminado m√°s tarde = mejor posici√≥n
      }
    }

    console.log(`   ü§ù EMPATE TOTAL entre ${a.name} y ${b.name}`);
    return 0;
  });

  console.log(`\nüìä RANKING FINAL POR RENDIMIENTO (PRIORIDAD ABSOLUTA):`);
  allPlayersSorted.forEach((p, i) => {
    const statusIcon = p.isAlive ? 'üü¢' : 'üî¥';
    const elimTime = p.eliminationTime ? new Date(p.eliminationTime).toISOString() : 'N/A';
    console.log(`   ${i + 1}. ${statusIcon} ${p.name}: ${p.correctAnswers}/${p.questionsAnswered} - eliminado: ${elimTime}`);
  });

  // 2. ASIGNAR POSICIONES CONSECUTIVAS (el mejor = posici√≥n 1)
  allPlayersSorted.forEach((player, index) => {
    const position = index + 1;
    positions[player.name] = position;

    // Actualizar en el lobby
    const lobbyPlayer = lobby.players.find((p: any) => p.name === player.name);
    if (lobbyPlayer) {
      lobbyPlayer.finalPosition = position;
      lobbyPlayer.won = position === 1;
    }

    stats[player.name] = {
      correctAnswers: player.correctAnswers || 0,
      questionsAnswered: player.questionsAnswered || 0,
      finalPosition: position,
      won: position === 1,
      isAlive: player.isAlive
    };

    const winIcon = position === 1 ? ' üëë GANADOR' : '';
    console.log(`   üèÖ #${position}: ${player.name} ‚Üí (${player.correctAnswers}/${player.questionsAnswered})${winIcon}`);
  });

  // 3. VERIFICACI√ìN FINAL
  const allPositions = Object.values(positions);
  const uniquePositions = new Set(allPositions);

  console.log(`\nüîç VERIFICACI√ìN FINAL:`);
  console.log(`   - Posiciones asignadas: [${allPositions.join(', ')}]`);
  console.log(`   - Total jugadores: ${totalPlayers}`);
  console.log(`   - Posiciones √∫nicas: ${uniquePositions.size}`);
  console.log(`   - ¬øCorrectas?: ${allPositions.length === totalPlayers && uniquePositions.size === totalPlayers ? '‚úÖ' : '‚ùå'}`);

  if (allPositions.length !== totalPlayers || uniquePositions.size !== totalPlayers) {
    console.error(`üö® ERROR EN RANKING DETECTADO - USANDO FALLBACK`);

    // üö® FALLBACK: Ordenar por correctAnswers primero, luego questionsAnswered
    const fallbackSorted = [...lobby.players].sort((a: any, b: any) => {
      const aScore = (a.correctAnswers || 0) * 1000 + (a.questionsAnswered || 0);
      const bScore = (b.correctAnswers || 0) * 1000 + (b.questionsAnswered || 0);
      return bScore - aScore;
    });

    const fallbackPositions: Record<string, number> = {};
    const fallbackStats: Record<string, any> = {};
    const fallbackRanking: string[] = [];

    fallbackSorted.forEach((player, index) => {
      const pos = index + 1;
      fallbackPositions[player.name] = pos;
      fallbackRanking.push(player.name);
      fallbackStats[player.name] = {
        correctAnswers: player.correctAnswers || 0,
        questionsAnswered: player.questionsAnswered || 0,
        finalPosition: pos,
        won: pos === 1,
        isAlive: player.isAlive
      };

      // Actualizar lobby
      const lobbyPlayer = lobby.players.find((p: any) => p.name === player.name);
      if (lobbyPlayer) {
        lobbyPlayer.finalPosition = pos;
        lobbyPlayer.won = pos === 1;
      }

      console.log(`   üîÑ FALLBACK #${pos}: ${player.name} ‚Üí ${player.correctAnswers}/${player.questionsAnswered}`);
    });

    return {
      positions: fallbackPositions,
      ranking: fallbackRanking,
      eliminationOrder: lobby.eliminationOrder || [],
      totalPlayers,
      stats: fallbackStats,
      winner: fallbackRanking[0]
    };
  }

  const finalRanking = Object.entries(positions)
    .sort(([, a], [, b]) => a - b)
    .map(([name]) => name);

  const winner = finalRanking[0];

  console.log(`\nüèÅ RANKING FINAL POR RENDIMIENTO:`);
  console.log(`   - üèÜ GANADOR: ${winner} (mejor rendimiento)`);
  console.log(`   - üìã Ranking: ${finalRanking.join(' ‚Üí ')}`);
  console.log(`   - üìä Estad√≠sticas usadas como criterio principal\n`);

  return {
    positions,
    ranking: finalRanking,
    eliminationOrder: lobby.eliminationOrder || [],
    totalPlayers,
    stats,
    winner
  };
}




// üö® NUEVAS VARIABLES GLOBALES para manejo de estad√≠sticas tard√≠as
const lobbyStatsTimeout = new Map<string, NodeJS.Timeout>();
const pendingStats = new Map<string, Set<string>>();



function finishGame(lobbyId: string, suggestedWinner: string | null) {
  if (finishedLobbies.has(lobbyId)) {
    console.log(`‚ö†Ô∏è Lobby ${lobbyId} ya finalizado, ignorando`);
    return;
  }

  finishedLobbies.add(lobbyId);

  console.log(`\nüèÅ ========== FINALIZANDO JUEGO ==========`);
  console.log(`üèÅ Lobby: ${lobbyId} | Ganador sugerido: ${suggestedWinner || 'NINGUNO'}`);

  const lobby = lobbies.find((l: any) => l.id === lobbyId);
  if (!lobby) {
    console.error(`‚ùå Lobby ${lobbyId} no encontrado`);
    finishedLobbies.delete(lobbyId);
    return;
  }

  lobby.gameState = 'finished';

  // ‚úÖ VALIDAR DATOS antes de crear ranking
  lobby.players.forEach((player: any) => {
    if (!player.isAlive && !player.eliminationTime) {
      player.eliminationTime = Date.now();
      console.log(`‚ö†Ô∏è Asignando timestamp faltante a ${player.name}`);
    }

    if (player.correctAnswers === undefined) player.correctAnswers = 0;
    if (player.questionsAnswered === undefined) player.questionsAnswered = 0;

    // ‚úÖ VALIDAR posiciones
    if (!player.finalPosition || player.finalPosition <= 0) {
      console.log(`‚ö†Ô∏è Posici√≥n inv√°lida para ${player.name}: ${player.finalPosition}`);
    }
  });

  const rankingData = createCorrectFinalRanking(lobby);
  if (!rankingData) {
    console.error("‚ùå Error generando ranking final");
    finishedLobbies.delete(lobbyId);
    return;
  }

  const { positions, ranking, eliminationOrder, totalPlayers, stats, winner } = rankingData;

  // ‚úÖ VALIDACI√ìN FINAL m√°s estricta
  const positionValues = Object.values(positions);
  const uniquePositions = new Set(positionValues);
  const hasValidPositions = positionValues.every(pos => pos >= 1 && pos <= totalPlayers);
  const hasCorrectCount = positionValues.length === totalPlayers;
  const hasUniquePositions = uniquePositions.size === totalPlayers;

  if (!hasValidPositions || !hasCorrectCount || !hasUniquePositions) {
    console.error(`üö® RANKING INV√ÅLIDO DETECTADO:`);
    console.error(`   - Posiciones v√°lidas: ${hasValidPositions}`);
    console.error(`   - Cantidad correcta: ${hasCorrectCount} (${positionValues.length}/${totalPlayers})`);
    console.error(`   - Posiciones √∫nicas: ${hasUniquePositions} (${uniquePositions.size}/${totalPlayers})`);
    console.error(`   - Posiciones: ${JSON.stringify(positions)}`);

    finishedLobbies.delete(lobbyId);
    return;
  }

  console.log(`üì§ ENVIANDO gameEnded final a ${lobby.players.length} jugadores`);

  // ‚úÖ ENVIAR con datos completos y validados
  lobby.players.forEach((player: any) => {
    const playerPosition = positions[player.name];
    const playerStats = stats[player.name];

    if (!playerPosition || !playerStats) {
      console.error(`‚ùå Datos faltantes para ${player.name}`);
      return;
    }

    console.log(`   üì§ ${player.name} ‚Üí Posici√≥n ${playerPosition}`);

    io.to(player.socketId).emit("gameEnded", {
      winner: winner,
      positions: positions,
      finalRanking: ranking,
      totalPlayers: totalPlayers,
      eliminationOrder: eliminationOrder,
      stats: stats,
      playerStats: {
        [player.name]: {
          correctAnswers: playerStats.correctAnswers,
          questionsAnswered: playerStats.questionsAnswered,
          finalPosition: playerPosition,
          won: playerPosition === 1,
          gameTime: formatGameTime(Date.now() - (lobby.startTime || Date.now()))
        }
      }
    });
  });

  console.log(`‚úÖ Juego finalizado correctamente: ${winner} gan√≥`);
  console.log(`üèÅ ========== FIN FINALIZACI√ìN ==========\n`);

  // Limpiar sesiones 
  lobby.players.forEach((player: any) => {
    SessionManager.setInGame(player.socketId, false);
    SessionManager.updateSessionLobby(player.socketId, null);
  });

  // üö® CR√çTICO: RETRASAR limpieza del lobby para permitir estad√≠sticas tard√≠as
  setTimeout(() => {
    console.log(`üßπ Limpiando lobby despu√©s de delay: ${lobbyId}`);
    cleanupLobby(lobbyId);
    finishedLobbies.delete(lobbyId);

    // Limpiar cualquier tracking de estad√≠sticas pendientes
    const timeoutId = lobbyStatsTimeout.get(lobbyId);
    if (timeoutId) {
      clearTimeout(timeoutId);
      lobbyStatsTimeout.delete(lobbyId);
    }
    pendingStats.delete(lobbyId);

  }, 60000); // 60 segundos en lugar de 30
}



function formatGameTime(milliseconds: number): string {
  const seconds = Math.floor(milliseconds / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}


io.on("connection", (socket) => {
  console.log("‚úÖ Nuevo jugador conectado:", socket.id);

  // ‚úÖ NUEVO: Heartbeat para mantener conexi√≥n activa
  const heartbeatInterval = setInterval(() => {
    if (socket.connected) {
      socket.emit("ping");
    }
  }, 30000); // Cada 30 segundos

  socket.on("pong", () => {
    console.log(`üíì Heartbeat recibido de ${socket.id}`);
    SessionManager.updateActivity(socket.id);
  });

  // ‚úÖ NUEVO EVENTO: Verificar sesi√≥n existente ANTES de login
  socket.on("checkExistingSession", (email: string) => {
    console.log(`üîç Verificando sesi√≥n existente para: ${email}`);

    const isConnected = SessionManager.isAccountConnected(email);
    const existingSession = SessionManager.getActiveSession(email);

    if (isConnected && existingSession) {
      console.log(`‚ö†Ô∏è Sesi√≥n activa encontrada para ${email}:`);
      console.log(`   - Socket: ${existingSession.socketId}`);
      console.log(`   - Lobby: ${existingSession.lobbyId}`);
      console.log(`   - En juego: ${existingSession.isInGame}`);

      socket.emit("existingSessionFound", {
        hasActiveSession: true,
        sessionData: {
          lobbyId: existingSession.lobbyId,
          isInGame: existingSession.isInGame,
          lastActivity: existingSession.lastActivity,
          name: existingSession.name
        }
      });
    } else {
      socket.emit("existingSessionFound", {
        hasActiveSession: false
      });
    }
  });



  // NUEVO: Evento para logout completo que limpia la sesi√≥n del servidor
  socket.on("logout", (data: { email: string }) => {
    console.log(`üö™ Logout completo solicitado para: ${data.email}`);

    // Obtener sesi√≥n antes de limpiar
    const session = SessionManager.getSessionBySocketId(socket.id);

    if (session && session.email === data.email) {
      console.log(`üóëÔ∏è Limpiando sesi√≥n completa para ${session.name} (${session.email})`);

      // Remover del lobby si est√° en uno
      const lobby = findLobbyBySocketId(socket.id);
      if (lobby) {
        const playerIndex = lobby.players.findIndex((p: any) => p.socketId === socket.id);
        if (playerIndex !== -1) {
          console.log(`üö∂ Removiendo ${session.name} del lobby ${lobby.id}`);
          lobby.players.splice(playerIndex, 1);

          // Notificar a otros jugadores en el lobby
          socket.to(lobby.id).emit("lobbyUpdate", lobby);
        }
      }

      // CR√çTICO: Remover sesi√≥n completamente del servidor
      SessionManager.removeSession(socket.id);

      console.log(`‚úÖ Logout completo exitoso para ${session.name}`);
    } else {
      console.log(`‚ö†Ô∏è No se encontr√≥ sesi√≥n v√°lida para logout: ${data.email}`);
    }
  });

  // ‚úÖ NUEVO EVENTO: Reconectar a sesi√≥n existente
  socket.on("reconnectToSession", (data: { email: string, name: string }) => {
    console.log(`üîÑ Reconectando a sesi√≥n existente: ${data.email}`);

    const existingSession = SessionManager.getActiveSession(data.email);
    if (!existingSession) {
      socket.emit("reconnectionFailed", { message: "Sesi√≥n no encontrada" });
      return;
    }

    // CR√çTICO: Desconectar sesi√≥n anterior ANTES de crear la nueva
    SessionManager.disconnectPreviousSession(io, existingSession.socketId, "Reconexi√≥n autorizada");

    // AGREGAR: Peque√±a pausa para asegurar desconexi√≥n completa
    setTimeout(() => {
      // Crear nueva sesi√≥n con los mismos datos
      const { currentSession } = SessionManager.createSession(socket.id, data.email, data.name);

      // Si ten√≠a un lobby, intentar reconectar
      if (currentSession.lobbyId) {
        const lobby = lobbies.find(l => l.id === currentSession.lobbyId);
        if (lobby) {
          console.log(`üè† Reconectando al lobby ${currentSession.lobbyId}`);

          // Actualizar socketId del jugador en el lobby
          const player = lobby.players.find(p => p.email === data.email);
          if (player) {
            player.socketId = socket.id;
            socket.join(lobby.id);

            // Actualizar estado de la sesi√≥n
            SessionManager.setInGame(socket.id, lobby.gameState === 'playing');

            socket.emit("reconnectedSuccessfully", {
              lobby: lobby,
              gameState: lobby.gameState,
              isInGame: lobby.gameState === 'playing'
            });

            // Notificar al resto del lobby
            socket.to(lobby.id).emit("lobbyUpdate", lobby);

            if (lobby.gameState === 'playing') {
              const aliveCount = getAlivePlayers(lobby.id).length;
              io.to(lobby.id).emit("updatePlayersLeft", aliveCount);
            }

            console.log(`‚úÖ ${data.name} reconectado exitosamente al lobby ${lobby.id}`);
            return;
          }
        }
      }

      // Si no hab√≠a lobby o no se pudo reconectar, sesi√≥n limpia
      socket.emit("reconnectedSuccessfully", {
        lobby: null,
        gameState: 'waiting',
        isInGame: false
      });
    }, 500); // Pausa para asegurar desconexi√≥n completa
  });

  // ‚úÖ NUEVO EVENTO: Forzar nueva sesi√≥n (desconectar la anterior)
  socket.on("forceNewSession", (data: { email: string, name: string }) => {
    console.log(`üí• Forzando nueva sesi√≥n para: ${data.email}`);

    const existingSession = SessionManager.getActiveSession(data.email);
    if (existingSession) {
      // CR√çTICO: Marcar sesi√≥n anterior como siendo reemplazada
      SessionManager.markSessionForReplacement(data.email);

      // Desconectar sesi√≥n anterior
      SessionManager.disconnectPreviousSession(io, existingSession.socketId, "Nueva sesi√≥n forzada");
    }

    // CAMBIO CR√çTICO: Crear nueva sesi√≥n INMEDIATAMENTE sin timeout
    // El timeout estaba causando que el cliente conectara antes de que el servidor limpiara
    const { currentSession } = SessionManager.createSession(socket.id, data.email, data.name);

    console.log(`‚úÖ Nueva sesi√≥n forzada creada inmediatamente: ${socket.id}`);

    socket.emit("newSessionCreated", {
      sessionId: currentSession.socketId,
      message: "Nueva sesi√≥n creada exitosamente"
    });
  });

  // üéÆ EVENTOS DE LOBBY MODIFICADOS

  // ‚úÖ MODIFICAR: Unirse a un lobby CON verificaci√≥n de sesi√≥n
  socket.on("joinLobby", (data: { playerName: string, email: string }) => {
    console.log(`üéÆ Intento de uni√≥n al lobby:`, data);

    try {
      const existingSession = SessionManager.getActiveSession(data.email);
      if (existingSession && existingSession.socketId !== socket.id && !existingSession.isBeingReplaced) {
        console.log(`‚ö†Ô∏è Sesi√≥n duplicada detectada para ${data.email}`);
        socket.emit("sessionConflict", {
          message: "Ya tienes una sesi√≥n activa en otro dispositivo",
          canReconnect: true
        });
        return;
      }

      const { currentSession } = SessionManager.createSession(socket.id, data.email, data.playerName);
      const lobby = joinLobby(data.playerName, socket.id, data.email);

      // ‚úÖ CR√çTICO: Unirse al room antes de emitir eventos
      socket.join(lobby.id);
      SessionManager.updateSessionLobby(socket.id, lobby.id);

      // ‚úÖ CONFIRMAR uni√≥n exitosa al cliente ANTES del broadcast
      socket.emit("lobbyJoinConfirmed", {
        lobbyId: lobby.id,
        message: "Te has unido al lobby exitosamente"
      });

      // Luego broadcast a todos
      io.to(lobby.id).emit("lobbyUpdate", lobby);
      console.log(`‚úÖ Jugador ${data.playerName} se uni√≥ a la sala ${lobby.id}`);

    } catch (error) {
      console.error("‚ùå Error en joinLobby:", error);
      socket.emit("joinLobbyError", {
        message: "Error al unirse al lobby"
      });
    }
  });

  // ‚úÖ MODIFICAR: Marcar jugador como listo CON actualizaci√≥n de actividad
  socket.on("playerReady", () => {
    console.log("üéØ Evento playerReady recibido de:", socket.id);

    try {
      SessionManager.updateActivity(socket.id);
      const lobby = setPlayerReady(socket.id);

      if (lobby) {
        console.log("‚úÖ Jugador marcado como listo en lobby:", lobby.id);

        // ‚úÖ CONFIRMAR al cliente que est√° listo
        socket.emit("readyConfirmed", {
          message: "Marcado como listo exitosamente"
        });

        io.to(lobby.id).emit("lobbyUpdate", lobby);

        if (lobby.started) {
          console.log("üöÄ Iniciando juego para lobby:", lobby.id);

          // Marcar jugadores como en juego
          lobby.players.forEach((player: any) => {
            SessionManager.setInGame(player.socketId, true);
          });

          // ‚úÖ SECUENCIA MEJORADA: Enviar eventos en orden espec√≠fico
          io.to(lobby.id).emit("startGame", {
            message: "Todos listos, partida iniciada!"
          });

          setTimeout(() => {
            io.to(lobby.id).emit("gameStarted", {
              totalPlayers: lobby.totalPlayersAtStart,
              playerList: lobby.players.map((p: any) => p.name)
            });

            const aliveCount = getAlivePlayers(lobby.id).length;
            io.to(lobby.id).emit("updatePlayersLeft", aliveCount);
          }, 500); // Dar tiempo para procesar startGame
        }
      } else {
        console.error("‚ùå No se pudo marcar jugador como listo");
        socket.emit("readyError", {
          message: "Error al marcar como listo"
        });
      }
    } catch (error) {
      console.error("‚ùå Error en playerReady:", error);
      socket.emit("readyError", {
        message: "Error interno del servidor"
      });
    }
  });

  // ‚úÖ MODIFICAR: Unirse directamente al juego CON verificaci√≥n de sesi√≥n
  socket.on("joinGame", (userData: { name: string, email: string }) => {
    console.log(`üéÆ ${userData.name} se une directamente al juego`);

    // Verificar sesi√≥n existente
    const existingSession = SessionManager.getActiveSession(userData.email);
    if (existingSession && existingSession.socketId !== socket.id) {
      console.log(`‚ö†Ô∏è Sesi√≥n duplicada detectada en joinGame para ${userData.email}`);
      socket.emit("sessionConflict", {
        message: "Ya tienes una sesi√≥n activa",
        canReconnect: true
      });
      return;
    }

    // Crear o actualizar sesi√≥n
    SessionManager.createSession(socket.id, userData.email, userData.name);

    const lobby = joinLobby(userData.name, socket.id, userData.email, 10);
    socket.join(lobby.id);

    // Actualizar sesi√≥n con lobby
    SessionManager.updateSessionLobby(socket.id, lobby.id);

    const updatedLobby = setPlayerReady(socket.id);

    if (updatedLobby) {
      io.to(lobby.id).emit("lobbyUpdate", updatedLobby);

      if (updatedLobby.started) {
        console.log("üöÄ Auto-iniciando juego para lobby:", lobby.id);

        // Marcar jugadores como en juego
        updatedLobby.players.forEach((player: any) => {
          SessionManager.setInGame(player.socketId, true);
        });

        io.to(updatedLobby.id).emit("gameStarted", {
          totalPlayers: updatedLobby.totalPlayersAtStart,
          playerList: updatedLobby.players.map((p: any) => p.name)
        });

        const aliveCount = getAlivePlayers(updatedLobby.id).length;
        io.to(updatedLobby.id).emit("updatePlayersLeft", aliveCount);
      }
    }
  });

  function formatGameTime(milliseconds: number): string {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  // ‚ùå Jugador perdi√≥/eliminado - CON actualizaci√≥n de actividad
  // MODIFICAR el evento playerLost para NO enviar gameEnded autom√°ticamente
  socket.on("playerLost", (data: {
    playerId?: string,
    playerName?: string,
    questionIndex?: number,
    correctAnswers?: number,
    questionsAnswered?: number
  }) => {
    console.log(`\n‚ùå ========== PLAYER LOST RECIBIDO ==========`);
    console.log(`‚ùå Socket: ${socket.id} | Conectado: ${socket.connected}`);
    console.log(`‚ùå Datos:`, JSON.stringify(data, null, 2));
    console.log(`‚ùå Timestamp: ${new Date().toISOString()}`);

    try {
      const lobby = findLobbyBySocketId(socket.id);

      // üö® MODIFICACI√ìN CR√çTICA: Buscar por NOMBRE DE JUGADOR, no por socket ID
      if (!lobby) {
        console.log(`‚ùå Lobby activo no encontrado para socket ${socket.id}`);

        // üö® NUEVO: Buscar lobbies pendientes por NOMBRE de jugador
        let foundPendingLobby = null;
        let foundLobbyData = null;

        for (const [lobbyId, expectedPlayers] of pendingStats.entries()) {
          console.log(`üîç Verificando lobby pendiente ${lobbyId} para jugador: ${data.playerName}`);
          console.log(`   Jugadores esperados: ${Array.from(expectedPlayers).join(', ')}`);

          if (expectedPlayers.has(data.playerName || '')) {
            foundPendingLobby = lobbyId;
            foundLobbyData = lobbies.find(l => l.id === lobbyId);
            break;
          }
        }

        if (foundPendingLobby && foundLobbyData) {
          console.log(`‚úÖ ENCONTRADAS ESTAD√çSTICAS TARD√çAS para ${data.playerName} en lobby ${foundPendingLobby}`);

          const targetPlayer = foundLobbyData.players.find(p => p.name === data.playerName);

          if (targetPlayer) {
            console.log(`üìä ACTUALIZANDO ESTAD√çSTICAS TARD√çAS de ${data.playerName}:`);
            console.log(`   Antes: ${targetPlayer.correctAnswers}/${targetPlayer.questionsAnswered}`);
            console.log(`   Recibido: ${data.correctAnswers}/${data.questionsAnswered}`);

            // ‚úÖ ACTUALIZAR estad√≠sticas con los datos reales
            targetPlayer.correctAnswers = data.correctAnswers || 0;
            targetPlayer.questionsAnswered = data.questionsAnswered || 0;

            console.log(`   Despu√©s: ${targetPlayer.correctAnswers}/${targetPlayer.questionsAnswered}`);
            console.log(`   üéØ ESTAD√çSTICAS TARD√çAS APLICADAS CORRECTAMENTE`);

            // Marcar como recibido
            const expectedPlayers = pendingStats.get(foundPendingLobby);
            if (expectedPlayers) {
              expectedPlayers.delete(data.playerName || '');
              console.log(`‚úÖ Estad√≠sticas de ${data.playerName} recibidas. Jugadores restantes: ${expectedPlayers.size}`);
              console.log(`   A√∫n esperando: ${Array.from(expectedPlayers).join(', ')}`);

              // Si ya recibimos todas las estad√≠sticas esperadas
              if (expectedPlayers.size === 0) {
                console.log(`üéØ TODAS LAS ESTAD√çSTICAS RECIBIDAS - Finalizando juego inmediatamente`);

                // Limpiar timeout
                const timeoutId = lobbyStatsTimeout.get(foundPendingLobby);
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  lobbyStatsTimeout.delete(foundPendingLobby);
                  console.log(`‚è∞ Timeout cancelado - procediendo con finalizaci√≥n`);
                }

                // Limpiar tracking
                pendingStats.delete(foundPendingLobby);

                // üö® CRUCIAL: Mostrar estad√≠sticas antes de finalizar
                console.log(`\nüìä ESTAD√çSTICAS FINALES ANTES DE RANKING:`);
                foundLobbyData.players.forEach(p => {
                  console.log(`   ${p.name}: ${p.correctAnswers}/${p.questionsAnswered}`);
                });

                // Finalizar juego con estad√≠sticas completas
                setTimeout(() => {
                  console.log(`üèÅ Iniciando finalizaci√≥n con estad√≠sticas completas`);
                  finishGame(foundPendingLobby, null);
                }, 500);
              }
            }

            // ‚úÖ RESPONDER al cliente
            socket.emit("eliminationConfirmed", {
              position: 2, // Posici√≥n temporal, se calcular√° correctamente en el ranking
              totalPlayers: foundLobbyData.totalPlayersAtStart || 2,
              correctAnswers: data.correctAnswers || 0,
              questionsAnswered: data.questionsAnswered || 0,
              message: "Estad√≠sticas tard√≠as recibidas correctamente"
            });

            console.log(`‚úÖ Estad√≠sticas tard√≠as procesadas exitosamente para ${data.playerName}`);
            console.log(`‚ùå ========== FIN PLAYER LOST (TARD√çAS PROCESADAS) ==========\n`);
            return;

          } else {
            console.error(`‚ùå No se encontr√≥ jugador ${data.playerName} en lobby ${foundPendingLobby}`);
          }
        } else {
          console.log(`‚ùå No se encontraron estad√≠sticas pendientes para ${data.playerName}`);
          console.log(`üìã Lobbies pendientes actuales:`);
          for (const [lobbyId, expectedPlayers] of pendingStats.entries()) {
            console.log(`   ${lobbyId}: esperando ${Array.from(expectedPlayers).join(', ')}`);
          }
        }

        // Si llegamos aqu√≠, no pudimos procesar las estad√≠sticas tard√≠as
        socket.emit("eliminationConfirmed", {
          position: 2,
          totalPlayers: 2,
          correctAnswers: data.correctAnswers || 0,
          questionsAnswered: data.questionsAnswered || 0,
          error: "No se pudo procesar estad√≠sticas tard√≠as"
        });

        console.log(`‚ùå ========== FIN PLAYER LOST (NO PROCESADAS) ==========\n`);
        return;
      }

      // ‚úÖ RESTO DEL C√ìDIGO PARA LOBBIES ACTIVOS (mantener igual)
      if (lobby.gameState !== 'playing') {
        console.log(`‚ö†Ô∏è Juego no activo en lobby ${lobby.id}, estado: ${lobby.gameState}`);

        socket.emit("eliminationConfirmed", {
          position: lobby.players.length,
          totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
          correctAnswers: data.correctAnswers || 0,
          questionsAnswered: data.questionsAnswered || 0,
          error: "Juego no activo"
        });
        return;
      }

      // PROCESAR ELIMINACI√ìN NORMAL (c√≥digo existente igual)
      const finalCorrectAnswers = data.correctAnswers !== undefined ? data.correctAnswers : 0;
      const finalQuestionsAnswered = data.questionsAnswered !== undefined ? data.questionsAnswered : 0;

      console.log(`üìä PROCESANDO ELIMINACI√ìN NORMAL CON ESTAD√çSTICAS:`);
      console.log(`   - Jugador: ${data.playerName || 'Desconocido'}`);
      console.log(`   - Correctas: ${finalCorrectAnswers}`);
      console.log(`   - Respondidas: ${finalQuestionsAnswered}`);

      const result = eliminatePlayerFromLobby(
        socket.id,
        data.questionIndex ?? 0,
        finalCorrectAnswers,
        finalQuestionsAnswered
      );

      if (!result) {
        console.error("‚ùå eliminatePlayerFromLobby fall√≥");
        socket.emit("eliminationConfirmed", {
          position: lobby.players.length,
          totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
          correctAnswers: finalCorrectAnswers,
          questionsAnswered: finalQuestionsAnswered,
          error: "Error procesando eliminaci√≥n"
        });
        return;
      }

      const { lobby: updatedLobby, player, position, remainingPlayers, automaticWinner } = result;

      console.log(`‚úÖ Eliminaci√≥n normal procesada: ${player.name} ‚Üí posici√≥n ${position}`);
      console.log(`üìä Estad√≠sticas confirmadas: ${player.correctAnswers}/${player.questionsAnswered}`);

      socket.emit("eliminationConfirmed", {
        position: position,
        totalPlayers: updatedLobby.totalPlayersAtStart || updatedLobby.players.length,
        correctAnswers: player.correctAnswers,
        questionsAnswered: player.questionsAnswered
      });

      io.to(updatedLobby.id).emit("playerEliminated", {
        playerName: player.name,
        position: position,
        playersLeft: remainingPlayers,
        eliminatedStats: {
          correctAnswers: player.correctAnswers,
          questionsAnswered: player.questionsAnswered
        }
      });

      if (automaticWinner && remainingPlayers === 1) {
        console.log(`üèÜ GANADOR AUTOM√ÅTICO: ${automaticWinner.name}`);
        io.to(automaticWinner.socketId).emit("automaticWinnerNotification", {
          message: "¬°Eres el ganador autom√°tico! Tu oponente fue eliminado.",
          position: 1,
          totalPlayers: updatedLobby.totalPlayersAtStart || updatedLobby.players.length,
          eliminatedPlayer: player.name
        });

        setTimeout(() => {
          finishGame(updatedLobby.id, automaticWinner.name);
        }, 3000);

      } else if (remainingPlayers === 0) {
        console.log("üíÄ Todos eliminados - terminando juego");
        setTimeout(() => finishGame(updatedLobby.id, null), 1000);

      } else {
        io.to(updatedLobby.id).emit("updatePlayersLeft", remainingPlayers);
      }

    } catch (error) {
      console.error("‚ùå Error cr√≠tico en playerLost:", error);
      socket.emit("eliminationConfirmed", {
        position: 2,
        totalPlayers: 2,
        correctAnswers: data.correctAnswers || 0,
        questionsAnswered: data.questionsAnswered || 0,
        error: "Error interno del servidor"
      });
    }

    console.log(`‚ùå ========== FIN PLAYER LOST ==========\n`);
  });

  // AGREGAR NUEVO EVENTO: Terminar juego manualmente como ganador autom√°tico
  socket.on("finishAsAutomaticWinner", (data: {
    correctAnswers: number,
    questionsAnswered: number,
    finalPosition?: number,
    won?: boolean
  }) => {
    console.log(`üèÅ finishAsAutomaticWinner recibido:`, data);

    const lobby = findLobbyBySocketId(socket.id);
    if (!lobby) {
      console.error("‚ùå Lobby no encontrado para finishAsAutomaticWinner");
      return;
    }

    const player = lobby.players.find(p => p.socketId === socket.id);
    if (!player) {
      console.error("‚ùå Jugador no encontrado para finishAsAutomaticWinner");
      return;
    }

    // ‚úÖ CR√çTICO: Actualizar estad√≠sticas CORRECTAS del ganador
    player.correctAnswers = data.correctAnswers;
    player.questionsAnswered = data.questionsAnswered;
    player.finalPosition = data.finalPosition || 1;
    player.won = data.won !== undefined ? data.won : true;
    player.isAlive = true; // ‚úÖ Mantener como vivo hasta el final

    console.log(`üèÜ ${player.name} termina como ganador con estad√≠sticas:`, {
      correctAnswers: player.correctAnswers,
      questionsAnswered: player.questionsAnswered,
      finalPosition: player.finalPosition,
      won: player.won
    });

    // ‚úÖ Marcar lobby como terminado
    lobby.gameState = 'finished';

    // ‚úÖ ASEGURAR que otros jugadores mantengan sus estad√≠sticas originales
    lobby.players.forEach((p: any) => {
      if (p.socketId !== socket.id && p.isAlive === false) {
        // ‚úÖ NO alterar las estad√≠sticas de jugadores ya eliminados
        console.log(`üìä Manteniendo estad√≠sticas de ${p.name}: ${p.correctAnswers}/${p.questionsAnswered} - Posici√≥n: ${p.finalPosition}`);
      }
    });

    // Finalizar el juego inmediatamente
    setTimeout(() => {
      finishGame(lobby.id, player.name);
    }, 500);
  });

  // Funci√≥n para guardar resultado de jugador eliminado
  async function saveEliminatedPlayerResult(gameData: any) {
    try {
      console.log("üíæ Guardando resultado de jugador eliminado:", gameData);

      const response = await fetch(`${process.env.NEXT_PUBLIC_URL_BASE || 'http://localhost:4000'}/api/results/save-result`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(gameData)
      });

      if (response.ok) {
        console.log("‚úÖ Resultado de jugador eliminado guardado correctamente");
      } else {
        console.error("‚ùå Error al guardar resultado eliminado:", await response.text());
      }
    } catch (err) {
      console.error("‚ùå Error guardando resultado eliminado:", err);
    }
  }





  socket.on("playerFinished", (data: {
    playerId: string,
    playerName: string,
    correctAnswers: number,
    questionsAnswered: number,
    completedAllQuestions: boolean
  }) => {
    console.log(`üèÅ playerFinished recibido de ${data.playerName}:`, data);

    const lobby = findLobbyBySocketId(socket.id);
    if (!lobby) {
      console.error("‚ùå Lobby no encontrado para playerFinished");
      return;
    }

    const player = lobby.players.find(p => p.socketId === socket.id);
    if (!player) {
      console.error("‚ùå Jugador no encontrado para playerFinished");
      return;
    }

    // Actualizar estad√≠sticas del jugador
    player.correctAnswers = data.correctAnswers;
    player.questionsAnswered = data.questionsAnswered;

    // ‚úÖ MARCAR como "terminado" pero NO como ganador autom√°ticamente
    player.hasCompletedAllQuestions = true;

    console.log(`üìä ${player.name} termin√≥ todas las preguntas: ${data.correctAnswers}/${data.questionsAnswered}`);

    // Verificar si este jugador debe ganar autom√°ticamente
    const alivePlayers = getAlivePlayers(lobby.id);
    const otherAlivePlayers = alivePlayers.filter(p => p.socketId !== socket.id);

    console.log(`üë• Jugadores vivos: ${alivePlayers.length}, otros vivos: ${otherAlivePlayers.length}`);

    if (otherAlivePlayers.length === 0) {
      // ‚úÖ Es el √∫ltimo superviviente
      console.log(`üèÜ ${player.name} es el √∫ltimo superviviente - GANADOR AUTOM√ÅTICO`);

      player.finalPosition = 1;
      player.won = true;

      // ‚úÖ Actualizar estad√≠sticas recibidas
      player.correctAnswers = data.correctAnswers;
      player.questionsAnswered = data.questionsAnswered;

      console.log(`üìä Estad√≠sticas finales del ganador: ${player.correctAnswers}/${player.questionsAnswered}`);

      // Enviar confirmaci√≥n de victoria
      socket.emit("victoryConfirmed", {
        position: 1,
        totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
        correctAnswers: player.correctAnswers,
        questionsAnswered: player.questionsAnswered,
        reason: "lastSurvivor"
      });

      // ‚úÖ CR√çTICO: Finalizar SOLO UNA VEZ con el ganador correcto
      setTimeout(() => {
        console.log(`üèÅ Finalizando juego con ganador: ${player.name}`);
        finishGame(lobby.id, player.name);
      }, 2000); // Dar tiempo para que el cliente procese la confirmaci√≥n

    } else {
      // ‚úÖ Hay otros jugadores vivos - solo notificar estado
      console.log(`‚è≥ ${player.name} termin√≥ pero otros siguen jugando: ${otherAlivePlayers.map(p => p.name).join(', ')}`);

      // ‚úÖ Actualizar estad√≠sticas del jugador que termin√≥
      player.correctAnswers = data.correctAnswers;
      player.questionsAnswered = data.questionsAnswered;
      player.hasCompletedAllQuestions = true;

      // Notificar a todos que este jugador termin√≥
      io.to(lobby.id).emit("playerFinishedAllQuestions", {
        playerName: player.name,
        correctAnswers: data.correctAnswers,
        questionsAnswered: data.questionsAnswered,
        playersStillPlaying: otherAlivePlayers.length
      });

      // Responder al jugador que debe esperar
      socket.emit("waitingForOthers", {
        message: "Has completado todas las preguntas. Esperando que otros jugadores terminen...",
        playersStillPlaying: otherAlivePlayers.length,
        otherPlayers: otherAlivePlayers.map(p => p.name)
      });
    }
  });






  // AGREGAR NUEVO EVENTO: Terminar juego manualmente como ganador autom√°tico
  socket.on("finishAsAutomaticWinner", (data: {
    correctAnswers: number,
    questionsAnswered: number
  }) => {
    console.log(`üèÅ Ganador autom√°tico decide terminar:`, data);

    // Actualizar actividad
    SessionManager.updateActivity(socket.id);

    const lobby = findLobbyBySocketId(socket.id);
    if (!lobby) {
      console.error("‚ùå Lobby no encontrado para finishAsAutomaticWinner");
      return;
    }

    const player = lobby.players.find(p => p.socketId === socket.id);
    if (!player) {
      console.error("‚ùå Jugador no encontrado para finishAsAutomaticWinner");
      return;
    }

    // Actualizar estad√≠sticas finales
    player.correctAnswers = data.correctAnswers;
    player.questionsAnswered = data.questionsAnswered;
    player.finalPosition = 1;
    player.won = true;
    player.isAlive = true;

    console.log(`üèÜ ${player.name} termina como ganador autom√°tico con ${data.correctAnswers}/${data.questionsAnswered}`);

    // Finalizar el juego
    finishGame(lobby.id, player.name);
  });

  // üèÜ Jugador gan√≥ - CON actualizaci√≥n de actividad
  socket.on("playerWon", (data: {
    playerId?: string,
    playerName?: string,
    correctAnswers?: number,
    questionsAnswered?: number
  }) => {
    console.log(`üèÜ ========== PLAYER WON RECIBIDO ==========`);
    console.log(`üèÜ Socket: ${socket.id} | Datos:`, data);

    try {
      SessionManager.updateActivity(socket.id);

      const lobby = findLobbyBySocketId(socket.id);
      if (!lobby) {
        console.log("‚ùå Lobby no encontrado para playerWon");

        // ‚úÖ RESPONDER incluso sin lobby
        socket.emit("victoryConfirmed", {
          position: 1,
          totalPlayers: 2,
          correctAnswers: data.correctAnswers || 0,
          questionsAnswered: data.questionsAnswered || 0
        });

        setTimeout(() => {
          socket.emit("gameEnded", {
            winner: data.playerName || "Ganador",
            positions: { [data.playerName || "Ganador"]: 1 },
            finalRanking: [data.playerName || "Ganador"],
            totalPlayers: 2,
            eliminationOrder: [],
            stats: {
              [data.playerName || "Ganador"]: {
                correctAnswers: data.correctAnswers || 0,
                questionsAnswered: data.questionsAnswered || 0,
                finalPosition: 1,
                won: true
              }
            }
          });
        }, 1000);
        return;
      }

      const player = lobby.players.find((p: any) => p.socketId === socket.id);
      if (!player) {
        console.log("‚ùå Jugador no encontrado para playerWon");
        socket.emit("victoryConfirmed", {
          position: 1,
          totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
          correctAnswers: data.correctAnswers || 0,
          questionsAnswered: data.questionsAnswered || 0
        });
        return;
      }

      // ‚úÖ CR√çTICO: ACTUALIZAR estad√≠sticas con los datos M√ÅS RECIENTES del cliente
      console.log(`üìä ACTUALIZANDO estad√≠sticas del ganador ${player.name}:`);
      console.log(`   Antes: ${player.correctAnswers}/${player.questionsAnswered}`);
      console.log(`   Datos recibidos: ${data.correctAnswers}/${data.questionsAnswered}`);

      // üö® USAR LOS DATOS M√ÅS ACTUALIZADOS DEL CLIENTE
      player.correctAnswers = data.correctAnswers !== undefined ? data.correctAnswers : player.correctAnswers || 0;
      player.questionsAnswered = data.questionsAnswered !== undefined ? data.questionsAnswered : player.questionsAnswered || 0;
      player.finalPosition = 1;
      player.won = true;
      player.isAlive = true;

      console.log(`   Despu√©s: ${player.correctAnswers}/${player.questionsAnswered}`);
      console.log(`üèÜ ${player.name} confirmado como GANADOR con estad√≠sticas actualizadas`);

      // Marcar otros jugadores como eliminados si no lo est√°n ya
      const otherAlivePlayers = lobby.players.filter((p: any) =>
        p.isAlive && p.socketId !== socket.id
      );

      console.log(`üìä Marcando ${otherAlivePlayers.length} jugadores restantes como eliminados`);

      otherAlivePlayers.forEach((otherPlayer: any, index: number) => {
        // üö® IMPORTANTE: NO alterar las estad√≠sticas de jugadores ya eliminados
        if (!otherPlayer.eliminationTime) {
          otherPlayer.eliminationTime = Date.now();
        }

        otherPlayer.isAlive = false;
        otherPlayer.won = false;

        // Solo asignar posici√≥n si no tiene una ya
        if (!otherPlayer.finalPosition || otherPlayer.finalPosition <= 0) {
          otherPlayer.finalPosition = index + 2; // Posiciones 2, 3, 4...
        }

        console.log(`   ${otherPlayer.name}: Posici√≥n ${otherPlayer.finalPosition} (estad√≠sticas preservadas: ${otherPlayer.correctAnswers}/${otherPlayer.questionsAnswered})`);
      });

      // ‚úÖ CONFIRMAR victoria al ganador
      socket.emit("victoryConfirmed", {
        position: 1,
        totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
        correctAnswers: player.correctAnswers,
        questionsAnswered: player.questionsAnswered
      });

      // Marcar lobby como terminado
      lobby.gameState = 'finished';
      lobby.lastActivity = Date.now();

      // ‚úÖ Finalizar juego con delay para procesar datos
      setTimeout(() => {
        console.log(`üèÅ Finalizando juego con ganador confirmado: ${player.name}`);
        finishGame(lobby.id, player.name);
      }, 1000);

    } catch (error) {
      console.error("‚ùå Error en playerWon:", error);

      socket.emit("victoryConfirmed", {
        position: 1,
        totalPlayers: 2,
        correctAnswers: data.correctAnswers || 0,
        questionsAnswered: data.questionsAnswered || 0,
        error: "Error interno"
      });
    }

    console.log(`üèÜ ========== FIN PLAYER WON ==========\n`);
  });




  //  Manejo de desconexi√≥n CON limpieza de sesi√≥n
  socket.on("disconnect", (reason) => {
    console.log(`\nüîå ========== DESCONEXI√ìN DETECTADA ==========`);
    console.log(`üîå Socket: ${socket.id} | Raz√≥n: ${reason}`);
    console.log(`üîå Timestamp: ${new Date().toISOString()}`);

    // Limpiar heartbeat
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
    }

    try {
      const session = SessionManager.getSessionBySocketId(socket.id);
      const lobby = findLobbyBySocketId(socket.id);

      if (session) {
        console.log(`üö∂ Sesi√≥n encontrada: ${session.name} (${session.email})`);

        if (session.isBeingReplaced) {
          console.log(`üîÑ Sesi√≥n reemplazada - limpieza completa`);
          SessionManager.removeSession(socket.id);
        } else {
          console.log(`‚è∞ Manteniendo sesi√≥n para reconexi√≥n`);
        }
      }

      if (!lobby) {
        console.log(`üè† Sin lobby asociado - solo limpieza de sesi√≥n`);
        console.log(`üîå ========== FIN DESCONEXI√ìN ==========\n`);
        return;
      }

      const player = lobby.players.find((p: any) => p.socketId === socket.id);
      if (!player) {
        console.log(`üë§ Jugador no encontrado en lobby`);
        console.log(`üîå ========== FIN DESCONEXI√ìN ==========\n`);
        return;
      }

      console.log(`üö∂ Desconexi√≥n: ${player.name} del lobby ${lobby.id}`);
      console.log(`üéÆ Estado del juego: ${lobby.gameState}`);
      console.log(`üë§ Jugador vivo: ${player.isAlive}`);
      console.log(`üìä Rendimiento actual: ${player.correctAnswers}/${player.questionsAnswered}`);

      // ‚úÖ CR√çTICO: Solo eliminar si el juego est√° activo y el jugador est√° vivo
      if (lobby.gameState === 'playing' && player.isAlive) {
        console.log(`üö´ Procesando desconexi√≥n durante juego activo: ${player.name}`);

        const eliminationTimestamp = Date.now();

        // üö® CONSERVAR estad√≠sticas existentes del jugador
        const currentCorrectAnswers = player.correctAnswers || 0;
        const currentQuestionsAnswered = player.questionsAnswered || 0;

        console.log(`üìä PRESERVANDO estad√≠sticas de ${player.name}:`);
        console.log(`   - Correctas: ${currentCorrectAnswers}`);
        console.log(`   - Respondidas: ${currentQuestionsAnswered}`);
        console.log(`   - Timestamp eliminaci√≥n: ${new Date(eliminationTimestamp).toISOString()}`);

        // Marcar como eliminado preservando estad√≠sticas
        player.isAlive = false;
        player.eliminationTime = eliminationTimestamp;
        player.won = false;
        // üö® NO alterar correctAnswers ni questionsAnswered aqu√≠

        // Agregar a orden de eliminaci√≥n si no est√°
        if (!lobby.eliminationOrder) lobby.eliminationOrder = [];
        if (!lobby.eliminationOrder.includes(player.name)) {
          lobby.eliminationOrder.push(player.name);
        }

        const remainingAlivePlayers = lobby.players.filter((p: any) => p.isAlive);
        const remainingCount = remainingAlivePlayers.length;

        console.log(`üìä Jugadores vivos restantes: ${remainingCount}`);
        console.log(`üìç ${player.name} eliminado por desconexi√≥n (posici√≥n se calcular√° por estad√≠sticas)`);

        // Notificar eliminaci√≥n por desconexi√≥n
        io.to(lobby.id).emit("playerEliminated", {
          playerName: player.name,
          position: -1, // Posici√≥n temporal, se calcular√° despu√©s
          playersLeft: remainingCount,
          reason: "disconnection",
          eliminatedStats: {
            correctAnswers: currentCorrectAnswers,
            questionsAnswered: currentQuestionsAnswered
          }
        });

        io.to(lobby.id).emit("updatePlayersLeft", remainingCount);

        // ‚úÖ NUEVO: MANEJAR FIN DE JUEGO CON DELAY PARA ESTAD√çSTICAS
        if (remainingCount <= 1) {
          if (remainingCount === 1) {
            const winner = remainingAlivePlayers[0];

            console.log(`üèÜ JUGADOR RESTANTE: ${winner.name} (continuar√° jugando)`);

            // Solo notificar que es el √∫ltimo superviviente
            io.to(winner.socketId).emit("automaticWinnerNotification", {
              message: "¬°Eres el √∫ltimo superviviente! Puedes continuar jugando o terminar ahora.",
              position: 1,
              totalPlayers: lobby.totalPlayersAtStart || lobby.players.length,
              eliminatedPlayer: player.name
            });

            // üö® CR√çTICO: NO finalizar inmediatamente - esperar estad√≠sticas

          } else {
            console.log(`üíÄ Todos eliminados por desconexi√≥n`);

            // üö® NUEVO: CONFIGURAR ESPERA DE ESTAD√çSTICAS
            console.log(`‚è≥ CONFIGURANDO ESPERA DE ESTAD√çSTICAS para lobby ${lobby.id}`);

            // Crear set de jugadores de los que esperamos estad√≠sticas
            const playersExpected = new Set<string>();
            lobby.players.forEach((p: any) => {
              // Solo esperar estad√≠sticas de jugadores que se desconectaron recientemente
              const timeSinceElimination = Date.now() - (p.eliminationTime || 0);
              if (timeSinceElimination < 30000) { // 30 segundos
                playersExpected.add(p.name);
                console.log(`   üìã Esperando estad√≠sticas de: ${p.name}`);
              }
            });

            pendingStats.set(lobby.id, playersExpected);

            // ‚úÖ TIMEOUT: Finalizar despu√©s de 15 segundos aunque no lleguen todas las estad√≠sticas
            const timeoutId = setTimeout(() => {
              console.log(`‚è∞ TIMEOUT: Finalizando juego ${lobby.id} por tiempo agotado`);
              console.log(`üìä Estad√≠sticas pendientes que no llegaron: ${Array.from(pendingStats.get(lobby.id) || []).join(', ')}`);

              // Limpiar tracking
              pendingStats.delete(lobby.id);
              lobbyStatsTimeout.delete(lobby.id);

              // Finalizar con las estad√≠sticas que tenemos
              finishGame(lobby.id, null);
            }, 15000); // 15 segundos de timeout

            lobbyStatsTimeout.set(lobby.id, timeoutId);

            console.log(`‚è≥ Esperando estad√≠sticas de ${playersExpected.size} jugadores durante m√°ximo 15 segundos...`);
          }
        }

      } else {
        // ‚úÖ SOLO remover del lobby si no est√° en juego
        console.log(`üö∂ Removiendo jugador del lobby (no en juego activo)`);
        const { shouldCleanup } = removePlayerFromLobby(socket.id);

        if (shouldCleanup) {
          console.log(`üßπ Lobby vac√≠o, ser√° limpiado autom√°ticamente`);
        } else if (lobby.players.length > 0) {
          io.to(lobby.id).emit("lobbyUpdate", lobby);
        }
      }

    } catch (error) {
      console.error("‚ùå Error manejando desconexi√≥n:", error);
    }

    console.log(`üîå ========== FIN DESCONEXI√ìN ==========\n`);
  });

  // ‚úÖ AGREGAR: Nuevo evento para manejar sessionReplaced en el cliente
  socket.on("sessionReplaced", (data: any) => {
    console.log(`üì± Cliente notificado de sesi√≥n reemplazada: ${socket.id}`);
    // El cliente debe manejar este evento y mostrar mensaje apropiado
    // No necesitamos hacer nada m√°s aqu√≠, el socket ya se desconectar√°
  });

  // üîß Debug: Obtener estado del lobby CON actualizaci√≥n de actividad
  socket.on("getLobbyState", () => {
    SessionManager.updateActivity(socket.id);

    const lobby = findLobbyBySocketId(socket.id);
    if (lobby) {
      socket.emit("lobbyState", {
        id: lobby.id,
        players: lobby.players.map((p: any) => ({
          name: p.name,
          isAlive: p.isAlive,
          finalPosition: p.finalPosition,
          correctAnswers: p.correctAnswers,
          questionsAnswered: p.questionsAnswered,
          won: p.won,
          eliminationTime: p.eliminationTime
        })),
        gameState: lobby.gameState,
        eliminationOrder: lobby.eliminationOrder,
        totalPlayersAtStart: lobby.totalPlayersAtStart
      });
    }
  });

  // ‚úÖ NUEVO EVENTO: Debug de sesiones
  socket.on("getSessionStats", () => {
    const stats = SessionManager.getStats();
    const currentSession = SessionManager.getSessionBySocketId(socket.id);

    socket.emit("sessionStats", {
      globalStats: stats,
      yourSession: currentSession ? {
        email: currentSession.email,
        name: currentSession.name,
        lobbyId: currentSession.lobbyId,
        isInGame: currentSession.isInGame,
        lastActivity: new Date(currentSession.lastActivity).toISOString(),
        joinTime: new Date(currentSession.joinTime).toISOString()
      } : null
    });
  });
});






// ‚úÖ AGREGAR: Endpoint para estad√≠sticas de sesiones
app.get("/api/sessions/stats", (req, res) => {
  const stats = SessionManager.getStats();
  res.json({
    success: true,
    data: stats,
    timestamp: new Date().toISOString()
  });
});

// ‚úÖ AGREGAR: Limpieza peri√≥dica cada 10 minutos
setInterval(() => {
  console.log("üßπ Ejecutando limpieza peri√≥dica de sesiones...");
  SessionManager.debugListSessions();
  const cleaned = SessionManager.cleanupInactiveSessions(15 * 60 * 1000); // 15 minutos
  if (cleaned > 0) {
    console.log(`üßπ Se limpiaron ${cleaned} sesiones inactivas`);
  }
}, 10 * 60 * 1000); // Cada 10 minutos

const PORT = process.env.PORT ? Number(process.env.PORT) : 4000;
const HOST = "0.0.0.0" as string;

server.listen(PORT, HOST, () => {
  console.log(`Servidor corriendo en http://${HOST}:${PORT}`);
});
